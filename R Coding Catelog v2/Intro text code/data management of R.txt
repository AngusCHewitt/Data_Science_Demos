#Download and run  packages
> install.packages("IPSUR")
> library(IPSUR)
> read(IPSUR)
>>data(package="car")
View a list of the datasets included in the XYZ file uploaded with datasets

1. c: If you would like to enter the data 74,31,95,61,76,34,23,54,96 into R, you may
create a data vector with the c function (which is short for concatenate).
> x <- c(74, 31, 95, 61, 76, 34, 23, 54, 96)

2. scan: This method is useful when the data are stored somewhere else. For instance, you
may type x <- scan()
#note need to place curssor in the middle of the scan() brackets and press enter to begin the scan.
need to leave the first cell (row ie a1 empty - program assuming that this will be a variable name) 

3. repeated data; regular patterns: the seq function will generate all sorts of sequences of numbers.
It has the arguments from, to, by, and length.out which can be set in concert with
one another. We will do a couple of examples to show you how it works.

> seq(from = 1, to = 5)

> seq(from = 2, by = -0.1, length.out = 4)

> 1:5
Indexing data vectors Sometimes we do not want the whole vector, but just a piece of it. We
can access the intermediate parts with the [] operator. Observe (with x defined above

> x[1]

> x[2:4]

> x[c(1, 3, 4, 8)]

> x[-c(1, 3, 4, 8)]

LETTERS[1:5]

#Logical Data, 
> x <- 5:9
> y <- (x < 7.3)
> y 
!y 

#Missing Data
> x <- c(3, 7, NA, 4, 7)
> y <- c(5, NA, 1, 2, 2)
> x + y

#Missing data need to be accounted for, the NA object can be removed from the vector using the na.rm arguement.   
> sum(x)
[1] NA
> sum(x, na.rm = TRUE)

#some functions do not have the option of using the above arguement, alternatively is can locate the NA and remove then using the [ ] function.
> is.na(x)
[1] FALSE FALSE TRUE FALSE FALSE
> z <- x[!is.na(x)]
> sum(z)
[1] 21


letters[-(6:24)] #Notice that we used the minus sign to specify those elements that we do not want

list of recently entered commands.
? To find out what all variables are in the current work environment, use the commands
objects() or ls(). These list all available objects in the workspace. If you wish to remove
one or more variables, use remove(var1, var2, var3), or more simply use rm(var1,
var2, var3), and to remove all objects use rm(list = ls()).

Ctrl + L # clear the console screen.

Dataset <- read.table("C:/Users/Angus/Desktop/Liver Size.csv", header=TRUE, 
  sep=",", na.strings="NA", dec=".", strip.white=TRUE)

# Label factors from numeric variables into factors (M/F, Vegetarian to Non Vegetarian)
Dataset <- within(Dataset, {Vegetarian <- factor(Vegetarian, labels=c('Vege','Non_Vege'))})

# Factors used to categorise data (R.V.)
> settings<-c("High","Medium","Low")
> settings<-factor(settings)

#Tell the user what variable type they are using
> mode(x)
[1] "numeric"
> mode(correctLogic)
[1] "logical"
> mode(incorrectLogic)
[1] "character 

#Matrix funtion

> mat<-matrix(c(2,3,1,5),nrow=2,ncol=2)

#Placing vectoring within a data.frame
> x<-c(1,3,2,1)
> y<-c(2,3,4,1)
> xy<-data.frame(x,y)

#Data Frames like a spreedsheet, each column is a vector, vector should be equal length, ecah column can be a diff. type vector but with each vector the they must be the 
same form.
> organism<-c("Human","Mouse","Fruit Fly", "Roundworm","Yeast")
> genomeSizeBP<-c(3000000000,3000000000,135600000,97000000,12100000)
> estGeneCount<-c(30000,30000,13061,19099,6034)

>comparativeGenomeSize<-
data.frame(organism=organism,genomeSizeBP=genomeSizeBP,
+ estGeneCount=estGeneCount)
> comparativeGenomeSize

> #create and bind column z to, rbind for rown and cbind for columns you wish to add.
> z<-c(2,1,4,7)
> xyz<-cbind(xy,z)

e#create and bind new row w
> w<-c(3,4,7)
> xyz<-rbind(xyz,w)

#checking data object type
> is.vector(x)
[1] TRUE
> is.data.frame(x)
[1] FALSE

#checking data mode
> is.character(x)
[1] FALSE
> is.numeric(x)

#procedures Eg of adding new variables  - in this instance a linear models residuals.

> mysuper$Trend <- with(mysuper, 0.32402+0.48971*X)

> mysuper$Res <- with(mysuper, Y- Trend)

> mysuper$Res <- with(mysuper, Y- Trend)



#change data object type
> y<-as.matrix(x)
[1] TRUE

#change functionality with the "as" function.
> z<-as.character(x)

#Find objects
>objects()
>Is()

#remove objects
>rm()

#rounding function
>round(x,n)

library(prob)


# Create a table object
table<-table(sgdata$Actual)
# Convert the table object to percentages
tablepercent<-100*table/sum(table)
# Create bar graph of percentages
barplot(tablepercent, xlab="Actual", ylab="Percent") 

#Create two-way table object
twowaytable <- table(Dataset$Expected, Dataset$Actual)
#Create cluster bar graph
barplot(prop.table(twowaytable,1),xlab="Actual", ylab="Percentage",col=c("blue","red","green"),
    legend = rownames(twowaytable), beside=TRUE,
    args.legend = list(x="topleft",title="Expected",bty="n"))

#Eg of uploading a dataset from desktop (CSV)
Dataset <- read.table("C:/Users/Angus/Desktop/Mental Arithmetic.csv", 
  header=TRUE, sep=",", na.strings="NA", dec=".", strip.white=TRUE)

#add some colour to the equation, also changed the width of the two boxplots
boxplot(Post~Condition, ylab="Post", xlab="Condition", data=Dataset, col="red", boxwex=.25)




#Lists the attributes of each columns (Var) and obserations (rows)
> attributes(Highway1)
$names
 [1] "rate"  "len"   "ADT"   "trks"  "sigs1" "slim"  "shld"  "lane"  "acpt" 
[10] "itg"   "lwid"  "hwy"  

$class
[1] "data.frame"

$row.names
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25
[26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39

#compute a new variable (column)
in this case created new var. SN (spped limit divided by the access points)
> Highway1$SN <- with(Highway1, slim/ acpt)

#what drive "R" will use as a defualt upload drive 
> getwd()
[1] "C:/Users/Angus/Documents"

#set new default drive
> setwd

#if data is saved in CSV -
> mysuper <- read.csv("My_Super.csv")

#uploading CSV from harddrive
> ExamAss = read.table("ExamAss.csv",header=TRUE,sep=",")
> ExamAss

sapply(explore, function(x)(sum(is.na(x)))) # NA counts
 
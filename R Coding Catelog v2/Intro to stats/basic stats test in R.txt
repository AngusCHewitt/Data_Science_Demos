
Intro to Stats

Search this site
CONTENTS
R BOOTCAMP
MYDESKTOP
DATA REPOSITORY
CLASS WORKSHEETS
GOOGLE+ COMMUNITY
FEEDBACK
CONTENTS
1 R Bootcamp Course 3: Basic Statistics in R
1.1 Learning Objectives
1.2 Diamonds Data
1.3 Qualitative Variables
1.3.1 Frequencies
1.3.2 Bar Charts
1.3.3 Cross-tabulations
1.3.4 Clustered Bar Charts
1.4 Quantitative
1.4.1 Dot plots
1.4.2 Histograms
1.4.3 Summary Statistics
1.4.4 Box Plots
1.4.5 Scatter Plots
R Bootcamp Course 3: Basic Statistics in R

Learning Objectives

By the end of this course, you will have covered the following:

Basic descriptive statistics for qualitative variables:
frequencies
cross-tabulations
bar charts
clustered bar charts.
Basic descriptive statistics for quantitative  variables:
Dot plots
Histograms
Mean and standard deviation
Quartiles, median, and IQR
Box plots
Side-by-side boxplots
Scatter plots
Diamonds Data

The following course will show you examples of  R code used for basic descriptive statistics and plots. Open RStudio and install and/or load the mosaic package. The mosaic package contains many useful functions for performing basic descriptive statistics.

> install.packages('mosaic')
> library(mosaic)
We will re-visit the large diamond dataset used in Module 2 available here - Diamonds. The dataset includes the prices and other attributes of almost 54,000 diamonds. The variables are as follows:

price. price in US dollars ($326 - $18,823)
carat. weight of the diamond (0.2 - 5.01)
cut. quality of the cut (Fair, Good, Very Good, Premium, Ideal)
colour. diamond colour, from J (worst) to D (best)
clarity. a measurement of how clear the diamond is (I1 (worst), SI1, SI2, VS1, VS2, VVS1, VVS2, IF (best))
x. length in mm (0--10.74)
y. width in mm (0--58.9)
z. depth in mm (0--31.8)
depth. total depth percentage = z / mean(x, y) = 2 * z / (x + y) (43--79)
table. width of top of diamond relative to widest point (43--95)
Using RStudio, import the Diamonds data (ensure you call the object "Diamonds"). Also ensure you define your factors correctly using the following code:  

> Diamonds$cut<- factor(Diamonds$cut, levels=c('Fair','Good','Very Good','Premium','Ideal'), 
                      ordered=TRUE)

> Diamonds$color<- factor(Diamonds$color, levels=c('J','I','H','G','F','E','D'), 
                        ordered=TRUE)

> Diamonds$clarity<-factor(Diamonds$clarity,levels=c('I1','SI1','SI2','VS1','VS2','VVS1','VVS2','IF'), ordered=TRUE)
This code ensures that cut, colour and clarity variables are treated correctly as ordered qualitative factors.

Now we are ready to start...

Qualitative Variables

Frequencies

Let's summarise the colour variable by counting the frequencies of different colour diamonds in the dataset. We use the tally() function:

> tally( ~ color, margins = TRUE, data = Diamonds)

    J     I     H     G     F     E     D Total 
 2808  5422  8304 11292  9542  9797  6775 53940
The margin option reports totals. Now, what if we want proportion reported instead? We add format = "proportion" to the code:

> tally( ~ cut, format="proportion", margins = TRUE, data = Diamonds)

      Fair       Good  Very Good    Premium      Ideal      Total 
0.02984798 0.09095291 0.22398962 0.25567297 0.39953652 1.00000000 
Note how the total equals 1. Percentages:

> tally( ~ color, format="percent", margins = TRUE, data = Diamonds)

         J          I          H          G          F          E          D      Total 
  5.205784  10.051910  15.394883  20.934372  17.690026  18.162773  12.560252 100.000000 
Easy!

Bar Charts

To create a bar chart summarising the percentage of colours in the sample, we first save the percentages into an object, called freq.

> freq <- tally( ~ color, format="percent", data = Diamonds)
After running this code, you should see "freq" appear in the environment window under Values. Well done! 

Next, we create a bar chart using this object.

> barplot(freq, main = "Diamond Cut Quality - Percentage",ylab="Percent", xlab="Colour")
Which produces:


Notice how the title, y and x axis labels were defined using main, ylab and xlab, respectively. If you want to add some colour...

> barplot(freq, main = "Diamond Cut Quality - Percentage",ylab="Percent", xlab="Colour",
  col="deepskyblue")
You can see all the colour options here. 


Cross-tabulations

Contingency tables or cross tabulations organise two qualitative variables into rows and columns. For example, what if we wanted to look at the relationship between colour and cut? We can modify the tally() function to report this:

> tally( ~ color | cut, margins=TRUE, data=Diamonds)

       cut
color    Fair  Good Very Good Premium Ideal
  J       119   307       678     808   896
  I       175   522      1204    1428  2093
  H       303   702      1824    2360  3115
  G       314   871      2299    2924  4884
  F       312   909      2164    2331  3826
  E       224   933      2400    2337  3903
  D       163   662      1513    1603  2834
  Total  1610  4906     12082   13791 21551
We can get the proportions using format = "proportion":

> tally( ~ color | cut, margins=TRUE, format = "proportion", data=Diamonds)
       cut
color         Fair       Good  Very Good    Premium      Ideal
  J     0.07391304 0.06257644 0.05611654 0.05858893 0.04157580
  I     0.10869565 0.10640033 0.09965238 0.10354579 0.09711846
  H     0.18819876 0.14309009 0.15096838 0.17112610 0.14454086
  G     0.19503106 0.17753771 0.19028307 0.21202233 0.22662521
  F     0.19378882 0.18528333 0.17910942 0.16902328 0.17753237
  E     0.13913043 0.19017530 0.19864261 0.16945834 0.18110529
  D     0.10124224 0.13493681 0.12522761 0.11623523 0.13150202
  Total 1.00000000 1.00000000 1.00000000 1.00000000 1.00000000
That's a little overzealous with the decimal places. We use the round() function to limit the table to three decimal places:

> round(tally( ~ color | cut, margins=TRUE, format = "proportion", data=Diamonds),3)

       cut
color    Fair  Good Very Good Premium Ideal
  J     0.074 0.063     0.056   0.059 0.042
  I     0.109 0.106     0.100   0.104 0.097
  H     0.188 0.143     0.151   0.171 0.145
  G     0.195 0.178     0.190   0.212 0.227
  F     0.194 0.185     0.179   0.169 0.178
  E     0.139 0.190     0.199   0.169 0.181
  D     0.101 0.135     0.125   0.116 0.132
  Total 1.000 1.000     1.000   1.000 1.000
That's better :)

Clustered Bar Charts

Clustered bar plots are a great way to help understand the relationships between two categorical variables. First, we save the contingency table as an object called color_cut:

> color_cut<-tally( ~ color | cut, format = "proportion", data=Diamonds)
Note how we removed margins = TRUE. We don't want the totals plotted. Next, we produce a basic bar chart.

> barplot(color_cut, main = "Diamond Colour by Cut Quality",ylab="Proportion within Cut",
        xlab="Cut")
> grid()

We add the grid() option to make the plot easier to read values off the axis. Not quite right. Lets add beside = TRUE to stack the bars next to each other:

> barplot(color_cut, main = "Diamond Colour by Cut Quality",ylab="Proportion within           Cut", xlab="Cut", beside=TRUE)
> grid()

Better, but we need to add a legend:

> barplot(color_cut, main = "Diamond Colour by Cut Quality",ylab="Proportion within Cut",
  xlab="Cut", beside=TRUE, legend=rownames(color_cut), args.legend=c(x = 
  "top",horiz=TRUE,title="Color"))
> grid()
We added legend = rownames(color_cut). This labels the legend using the row names (diamond colour names). The args.legend() option instructs R where to place the legend relative to the plot and its title. 


Getting closer... However, the legend overlaps the bars! Let's adjust the y-axis to increase the white space in the top of the plot, using the ylim option.

> barplot(color_cut, main = "Diamond Colour by Cut Quality",ylab="Proportion within Cut",
  xlab="Cut", beside=TRUE, legend=rownames(color_cut), args.legend=c(x = "top",horiz=TRUE,title="Cut"),
  ylim = c(0,.30))
> grid()

Better, but it's hard to differentiate between the grey colours! Let's use some more vibrant colour. We can use the col=rainbow() option. We need 7 colours, starting at red, and progressing 25% in the colour spectrum, so we use col=rainbow(7, start = 0, end = .25).

> barplot(color_cut, main = "Diamond Colour by Cut Quality",ylab="Proportion within Cut",
        xlab="Cut", beside=TRUE, 
        legend=rownames(color_cut), 
        args.legend=c(x = "top",horiz=TRUE,title="Color"),
        ylim = c(0,.30),
        col=rainbow(7, start = 0, end = .25))
> grid()

Cool!
Quantitative

Dot plots

Dot plots are a great visualisation for small samples. For example, let's create a dot plot of a random sample of 30 diamonds' mass measured in carats. We make use of the sample() function, which we will re-visit in Module 5. Before we do this, we will set the seed to the random number generator built into R:

> set.seed(4532)
This ensures you can replicate the exact same random sample used in this example. Now to the dot plot:

> dotPlot(sample(Diamonds$carat,size=30),xlab='Carat')
Notice how we have used the sample() function to randomly sample 30 diamonds' carat measurements. Here's the result:

 
We can use the nint option to change the number stacks or breaks in the dot plot. 

> set.seed(4532)
> dotPlot(sample(Diamonds$carat,size=30), xlab = 'Carat', nint = 3)

Histograms

Let's look at a histogram of diamond depths.

> hist(Diamonds$z,xlab="Diamond Depth (mm)", main="Histogram of Diamond Depths (mm)", col =
    "dodgerblue3")

Hmm, something is not right here. I think there are some extremely small and large values...

> min(Diamonds$z)
[1] 0
> max(Diamonds$z)
[1] 31.8
We have some diamonds with 0 depth (impossible and probably a data entry error) and a diamond with a depth of 31mm! Probably another error, as the carat measurement for this case is only .5. Let's focus our attention on diamonds between 2 and 6 mm using the subset() function. We will call the filtered data file object, Diamonds_clean.

> Diamonds_clean <- subset(Diamonds, z < 6 & z > 2)
Now re-run the histogram on the filtered data:

> hist(Diamonds_clean$z,xlab="Diamond Depth (mm)",
     main="Histogram of Diamond Depths (mm)", col = "dodgerblue3")

That's better :)
We can also panel histograms to help us compare a quantitative variable across categories, e.g. cut. We have to use a slightly different histogram() function:

> histogram(~ z|cut,col="dodgerblue3",layout=c(1,5),data=Diamonds_clean,xlab="Depth (mm)")

Summary Statistics

R has many built-in functions and other functions available in various packages to quickly summarise your data. The following code will show you the basic functions. We will summarise the carat variable:

> mean(Diamonds$carat) #Mean
[1] 0.7979397
> 
> range(Diamonds$carat) #Min and Max
[1] 0.20 5.01
> 5.01 - 0.20 #Calculate range
[1] 4.81
> 
> var(Diamonds$carat) #Variance
[1] 0.2246867
> 
> sd(Diamonds$carat) #Standard deviation
[1] 0.4740112
> 
> quantile(Diamonds$carat) #Quartiles Q1, Q2 and Q3
  0%  25%  50%  75% 100% 
0.20 0.40 0.70 1.04 5.01 
> 
> IQR(Diamonds$carat) #Interquartile range
[1] 0.64
> 
> median(Diamonds$carat) # Median
[1] 0.7
The mosaic package also includes a useful function, favstats() for obtaining the most common descriptive statistics for quantitative variables. For example, if we wanted to quickly summarise the carat variable:

> favstats( ~ carat, data = Diamonds) #Quick summary statistics

 min  Q1 median   Q3  max      mean        sd     n missing
 0.2 0.4    0.7 1.04 5.01 0.7979397 0.4740112 53940       0
favstats() can also quickly summarise a quantitative variable by a qualitative variable. For example, summarise carat by cut:

> favstats(~ carat | cut, data = Diamonds) #One quantitative and one qualitative variable

        cut  min   Q1 median   Q3  max      mean        sd     n missing
1      Fair 0.22 0.70   1.00 1.20 5.01 1.0461366 0.5164043  1610       0
2      Good 0.23 0.50   0.82 1.01 3.01 0.8491847 0.4540544  4906       0
3 Very Good 0.20 0.41   0.71 1.02 4.00 0.8063814 0.4594354 12082       0
4   Premium 0.20 0.41   0.86 1.20 4.01 0.8919549 0.5152616 13791       0
5     Ideal 0.20 0.35   0.54 1.01 3.50 0.7028370 0.4328763 21551       0
... and two quantitative variables!  Notice how cut and color are combined. For example, Fair.J refers to the summary statistics for the fair cut diamonds with J colour. We can see there were 119 of these diamonds. 

> favstats(~ carat | cut + color, data = Diamonds)

     cut.color  min     Q1 median     Q3  max      mean        sd    n missing
1       Fair.J 0.30 0.9050  1.030 1.6850 5.01 1.3411765 0.7339713  119       0
2       Good.J 0.28 0.7100  1.020 1.5000 3.00 1.0995440 0.5371248  307       0
3  Very Good.J 0.24 0.7100  1.060 1.5100 2.74 1.1332153 0.5559197  678       0
4    Premium.J 0.30 0.8100  1.250 1.7000 4.01 1.2930941 0.6137086  808       0
5      Ideal.J 0.23 0.5400  1.030 1.4100 3.01 1.0635937 0.5821001  896       0
6       Fair.I 0.41 0.8850  1.010 1.5050 3.02 1.1980571 0.5219776  175       0
7       Good.I 0.30 0.7000  1.000 1.5000 3.01 1.0572222 0.5756366  522       0
8  Very Good.I 0.24 0.7000  1.005 1.5000 4.00 1.0469518 0.5519840 1204       0
9    Premium.I 0.23 0.5900  1.140 1.5400 4.01 1.1449370 0.6136041 1428       0
10     Ideal.I 0.23 0.4100  0.740 1.2200 3.22 0.9130291 0.5537277 2093       0
11      Fair.H 0.33 0.9000  1.010 1.5100 4.13 1.2191749 0.5482389  303       0
12      Good.H 0.25 0.5100  0.900 1.0900 3.01 0.9147293 0.4977162  702       0
13 Very Good.H 0.23 0.4675  0.900 1.2000 3.00 0.9159485 0.5029465 1824       0
14   Premium.H 0.23 0.5100  1.010 1.3000 3.24 1.0164492 0.5440777 2360       0
15     Ideal.H 0.23 0.3600  0.700 1.1100 3.50 0.7995249 0.4868741 3115       0
16      Fair.G 0.23 0.7000  0.980 1.0675 2.60 1.0238217 0.4927241  314       0
17      Good.G 0.23 0.5000  0.900 1.0100 2.80 0.8508955 0.4327176  871       0
18 Very Good.G 0.23 0.4000  0.700 1.0200 2.52 0.7667986 0.4180156 2299       0
19   Premium.G 0.23 0.4000  0.755 1.1200 3.01 0.8414877 0.4795344 2924       0
20     Ideal.G 0.23 0.3400  0.540 1.0300 2.54 0.7007146 0.4106182 4884       0
21      Fair.F 0.25 0.6000  0.900 1.0100 2.58 0.9047115 0.4188899  312       0
22      Good.F 0.23 0.4900  0.710 1.0100 2.67 0.7759296 0.3700142  909       0
23 Very Good.F 0.23 0.4000  0.700 1.0100 2.48 0.7409612 0.3888827 2164       0
24   Premium.F 0.20 0.4300  0.760 1.0400 3.01 0.8270356 0.4201959 2331       0
25     Ideal.F 0.23 0.3500  0.530 0.9000 2.45 0.6558285 0.3745245 3826       0
26      Fair.E 0.22 0.5525  0.900 1.0100 2.04 0.8566071 0.3645848  224       0
27      Good.E 0.23 0.4100  0.700 1.0000 3.00 0.7451340 0.3808900  933       0
28 Very Good.E 0.20 0.3700  0.570 0.9400 2.51 0.6763167 0.3779140 2400       0
29   Premium.E 0.20 0.3800  0.580 1.0000 3.05 0.7177450 0.4097847 2337       0
30     Ideal.E 0.20 0.3300  0.500 0.7200 2.28 0.5784012 0.3125406 3903       0
31      Fair.D 0.25 0.7000  0.900 1.0100 3.40 0.9201227 0.4054185  163       0
32      Good.D 0.23 0.4200  0.700 1.0000 2.04 0.7445166 0.3631169  662       0
33 Very Good.D 0.23 0.4000  0.610 1.0000 2.58 0.6964243 0.3692291 1513       0
34   Premium.D 0.20 0.4000  0.580 1.0100 2.57 0.7215471 0.3974635 1603       0
35     Ideal.D 0.20 0.3300  0.500 0.7100 2.75 0.5657657 0.2993503 2834       0
Box Plots

Let's get a box plot of the carat variable using R:

> boxplot(Diamonds$carat, main="Box Plot of Diamond Carat",  ylab="Carat", col = "chartreuse3")
 
We use a formula, carat ~ cut, and add data = Diamonds, to produce a side-by-side boxplot:

> boxplot(carat ~ cut, data=Diamonds, main="Box Plot of Diamond Carat by Cut", 
  ylab="Carat", xlab = "cut", col=cm.colors(5))
Notice how we produced five colours using the cm.colors() palette.


Scatter Plots

Scatter plots are produced using the generic plot() function. For example, let's get a scatter plot of diamond width (y) length (x) measured in mm:

> plot(y ~ x, data = Diamonds, ylab="Width (mm)", xlab="Length (mm)", col="orangered",
  main="Length by Width")

Hmm, we have outliers at Length = 0 mm and widths > 20 mm that are distorting the main trend. Let's filter them out and re-do the scatter:

> Diamonds_clean<-subset(Diamonds, y < 20 & x > 0)
Now for the scatter based on the filtered dataset, Diamonds_clean.

> plot(y ~ x, data = Diamonds_clean, ylab="Width (mm)", xlab="Length (mm)",
  col="orangered",main="Length by Width")

Now the trend is more apparent. We should investigate the outliers to determine their cause.

Return to top
Recent Site Activity|Report Abuse|Print Page|Remove Access|Powered By Google Sites
##------ builid shiny web apps -----------####


# app have 2 main components
1/ UI or user interface: build input interface for users - layout, sidebars - canvas portion of app - template 
2/ server - this part of workflow process the data to produce an output (i.e. calcs, plot generated)
 
##-- input --##
interactive tools for users - click button, password box, slidebars ....

*Input - for most input funs ie textInput
argument include: inputid - unqie ids used to retrieve values
labels  = titles and headings
value = inital value given as default
value2= set parameter for numeric input box - min/max values


##-- Outputs --##

2 step process

1. ui <- fliudPage(
plotOutput(outputId = "my_plot" <- unique output id used to identify which plot to diaplay

2. R code used to generate the output

*server is a function with 2 argu; input and outputs - both are similar to lists

> inputs: read value from (input fo the user to modify)
> output: write values to ---- (output table or plot)

# rule for building any output object:
1. build obect inside a render fun (i.e. renderPlot, render*..)
2. Store object in output list - output$<outputId>
3. Allow user manpulate values use input$<inputId> - access value of input

 
# intro to shiny 

##---  create blank UI with function fluidPage() -----##

# Load the shiny package
library(shiny)


# Define UI for the application



##-- EG1 
ui <- fluidPage(
  
# Add the text 
"Shiny is fun"
)

# Define the server logic

server <- function(input, output) {} 



# Run the application

shinyApp(ui = ui, server = server)

##-- EG2
# Define UI for the application

ui <- fluidPage(
  # "DataCamp" as a primary header
  h1("DataCamp"),
  
# "Shiny use cases course" as a secondary header
  h2 ("Shiny use cases course"),
  
# "Shiny" in italics
  em("Shiny"),
  # "is fun" as bold text
  
strong("is fun")
)

# Define the server logic


server <- function(input, output) {}


# Run the application

shinyApp(ui = ui, server = server)

# Add structure to app with layout functions
# Define UI for the application

##-- EG1
ui <- fluidPage(
  # Add a sidebar layout to the application
  
sidebarLayout(
 # Add a sidebar panel around the text and inputs
    
sidebarPanel(
 h4("Plot parameters"),
 textInput("title", "Plot title", "Car speed vs distance to stop"),
      
numericInput("num", "Number of cars to show", 30, 1, nrow(cars)),
 sliderInput("size", "Point size", 1, 5, 2, 0.5)
 ),
    
# Add a main panel around the plot and table
 mainPanel( plotOutput("plot"),
 tableOutput("table")
 )

##---------- Adding inputs ------------------##

library(shiny)


# Step1. Define UI for the application (template)

ui <- fluidPage(
  
# Create a numeric input with ID "age" and label of
  
# "How old are you?"
  
numericInput(inputId = "age", label = "How old are you?", value = 20),
  
  

# Create a text input with ID "name" and label of 
  
# "What is your name?"
  
textInput(inputId = "name", label = "What is your name?")
)



# Define the server 
logic
server <- function(input, output) {}

# Run the application
shinyApp(ui = ui, server = server)

##----- adding outputs ----###


# Define UI for the application

ui <- fluidPage(
sidebarLayout(sidebarPanel(
# Create a text input with an ID of "name"
 
textInput(inputId = "name", "What is your name?", "Dean"),
numericInput("num", "Number of flowers to show data for",10, 1, nrow(iris))
),mainPanel(
 

# Add a placeholder for a text output with ID "greeting"
      
textOutput(outputId = "greeting"),
      

# Add a placeholder for a plot with ID "cars_plot"
      
plotOutput("cars_plot"),
      

# Add a placeholder for a table with ID "iris_table"
      
tableOutput("iris_table")
)
)

Constructing output objects
There are three rules to build an output in Shiny:


##-- construcint putput objects

Build the object with the appropriate render*() function.
Save the result of the render function into the output list, 
which is a parameter of the server function. Specifically, save it into output$<outputId> 
in order to replace the output placeholder in the UI that has ID outputId.
If the output relies on any user-modified input values, you can access any of the 
inputs using the input parameter of the server function. Specifically, input$<inputId> will always return the current value of the input field that has ID inputId.


##-- Reactive variables

All variables in shiny are reactive
when x chnages all values depending on x will change (re-render)
reactive values only work with a reactive context
render funs are reactive context
try access reactive values outside context will return an error
need to create reactive values - create context
access a reactive values use observe({..}) fun. - reactive context env.

useful dedugging tool - observe
nay dependency is update with the observe fun all reactive will update
also create reactive vars with reactive[{..}] - also create reactive env. 
to access reactive vas with observe (ones you have created) need to  name_var() i.e. scatter_plot(), x()


##-- plot app - Gapminder dt

Plot the data
Recall that plots are output objects, and as such they are added to a Shiny app using the plotOutput() + renderPlot() functions. 
The output function is added to the UI to determine where to place the plot, 
and the render function in the server code is responsible for generating the plot.


ui <- fluidPage(
  h1("Gapminder"),
  sliderInput(inputId = "life", label = "Life expectancy",
 min = 0, max = 120,
 value = c(30, 50)),
  selectInput("year", "Year",
 
choices = c("All", levels(as.factor(gapminder$year)))),
  downloadButton("download_data"),
  plotOutput("plot"),
  

# Replace the tableOutput() with DT's version
  
DT::dataTableOutput("table")
)


server <- function(input, output) {
  filtered_data <- reactive({
data <- gapminder
    
data <- subset(
data,
 lifeExp >= input$life[1] & lifeExp <= input$life[2]
)
    
if (input$year!= "All") {
data <- subset(data,
year == input$year)}
 data
  })
  
  

# Replace the renderTable() with DT's version
  
output$table <- DT::renderDataTable({
data <- filtered_data()
 data
  })

  
output$download_data <- downloadHandler(
    filename = "gapminder_data.csv",
 content = function(file) {
 
data <- filtered_data()
      write.csv(data, file, row.names = FALSE)
    }
  )

 
output$plot <- renderPlot({
data <- filtered_data()
    
ggplot(data, aes(gdpPercap, lifeExp)) +
 geom_point() +
 scale_x_log10()
  })
}

shinyApp(ui, server)

##-- add tabs to split the different outputs
ui <- fluidPage(
    h1("Gapminder"),
    
# Create a container for tab panels
    tabPanel(
        
# Create an "Inputs" tab
        
tabsetPanel(title = "Inputs",
sliderInput(inputId = "life", label = "Life expectancy",min = 0, max = 120, value = c(30, 50)), 
selectInput("continent", "Continent",
 choices = c("All", levels(gapminder$continent))),
 downloadButton("download_data")
        ),
        


# Create a "Plot" tab
        
tabPanel(title = "Plot",
plotOutput("plot")
        ),
        

# Create "Table" tab
        
TabPanel(title = "Table",
DT::dataTableOutput("table")
))
)

server <- function(input, output) {
  
filtered_data <- reactive({
data <- gapminder
    data <- subset(
      data,
      lifeExp >= input$life[1] & lifeExp <= input$life[2]
)
    if (input$continent != "All") {
      
data <- subset(
        data,
        continent == input$continent
      )
    }
    data
  })
  
  output$table <- DT::renderDataTable({
    data <- filtered_data()
    data
  })

  
output$download_data <- downloadHandler(
    filename = "gapminder_data.csv",
    content = function(file) {
      data <- filtered_data()
      write.csv(data, file, row.names = FALSE)
    }
  )

  
output$plot <- renderPlot({
    data <- filtered_data()
    ggplot(data, aes(gdpPercap, lifeExp)) +
      geom_point() +
      scale_x_log10()
  })
}

shinyApp(ui, server)



# Three components template for Shiny app

# tell shiny where to place objects
ui <- fluidPage(
)

# tell shiny how to manpulate object to produce output
# give user options to select input to produce particulr output

server <- function(input, output) {} 



# tie userinterface and server processes together 

shinyApp(ui = ui, server = server)







